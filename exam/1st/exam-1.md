## DynamoDB の長期データ保持とバックアップ戦略

```mermaid
graph TD
    subgraph "要件分析"
        R1[最低5年間の保持] -->|必須要件| R4[長期保存]
        R2[常時アクセス可能] -->|必須要件| R5[高可用性]
        R3[効率的な運用] -->|必須要件| R6[自動化]
    end

    subgraph "ソリューション比較"
        B1[AWS Backup] -->|"✓ 推奨"| F1["- 自動バックアップ<br>- 長期保持可能<br>- 効率的な運用"]
        B2[PITR] -->|"× 不適"| F2["- 35日間限定<br>- 短期復旧用<br>- 長期保存不可"]
        B3[オンデマンド] -->|"× 不適"| F3["- 手動操作必要<br>- 運用負荷大<br>- ミス発生リスク"]
        B4[TTL] -->|"× 不適"| F4["- データ削除機能<br>- 保存と逆行<br>- 要件非対応"]

        style B1 fill:#90EE90
        style B2,B3,B4 fill:#FFB6C1
    end
```

### 正解: B. AWS Backup を使用

AWS Backup は以下の理由で最適な選択となります：

1. **長期保存対応**

   - 5 年以上のデータ保持が可能
   - 柔軟な保持ポリシー設定
   - コンプライアンス要件に対応

2. **自動化された運用**

   - バックアップスケジュールの自動設定
   - 定期的なバックアップの自動実行
   - 人的ミスのリスク軽減

3. **効率的な管理**
   - 一元的なバックアップ管理
   - ライフサイクル管理の自動化
   - 運用コストの最適化

### 他の選択肢が不適切な理由

```mermaid
graph TD
    subgraph "各選択肢の問題点"
        A[PITR] -->|制限| A1["35日間限定の<br>バックアップ期間"]
        C[オンデマンド<br>バックアップ] -->|課題| C1["手動操作による<br>運用負荷増大"]
        D[TTL] -->|不適合| D1["データ削除機能で<br>保存要件と矛盾"]
    end
```

1. **選択肢 A（PITR）**

   - 35 日間のみのバックアップ保持
   - 5 年間の要件を満たせない
   - 長期保存には不向き

2. **選択肢 C（オンデマンドバックアップ）**

   - 手動操作が必要
   - 運用負荷が高い
   - ヒューマンエラーのリスク
   - スケーリングが困難

3. **選択肢 D（TTL）**
   - データを削除する機能
   - 長期保存の目的と逆行
   - バックアップとして機能しない

### AWS Backup の具体的な利点

```mermaid
graph TD
    subgraph "AWS Backupの主要機能"
        F1[自動化] -->|設定| F1_1["スケジュール<br>バックアップ"]
        F2[保持管理] -->|設定| F2_1["長期保持<br>ポリシー"]
        F3[効率化] -->|実現| F3_1["運用負荷<br>最小化"]
    end
```

1. **バックアップ管理**

   - 定期的なバックアップスケジュール
   - 自動実行による確実性
   - 統合された管理コンソール

2. **保持ポリシー**

   - 長期保存の自動化
   - きめ細かい保持ルール
   - コンプライアンス対応

3. **コスト最適化**
   - 効率的なストレージ利用
   - 自動化による運用コスト削減
   - スケーラブルな管理

## DynamoDB のキャパシティモードと使い分け

```mermaid
graph TD
    subgraph "キャパシティモードの比較"
        OD[オンデマンド] -->|"✓ 適合"| OD_USE["用途:<br>- 予測不能なトラフィック<br>- 急激な負荷変動<br>- 開発/テスト環境"]
        AS[オートスケーリング] -->|"△ 条件付き"| AS_USE["用途:<br>- 緩やかな負荷変動<br>- 予測可能なパターン<br>- 数分の遅延許容"]
        PR[プロビジョンド] -->|"× 不適"| PR_USE["用途:<br>- 安定したトラフィック<br>- 予測可能な負荷<br>- コスト重視"]
        LSI[LSI] -->|"× 対象外"| LSI_USE["用途:<br>- クエリの最適化<br>- データアクセスパターン<br>- 検索効率化"]

        style OD fill:#90EE90
        style AS,PR,LSI fill:#FFB6C1
    end
```

### 各選択肢の特徴と適したユースケース

1. **ローカルセカンダリインデックス（LSI）**

   - **主な用途**

     - 複雑なクエリの最適化
     - 代替的なデータアクセスパターンの提供
     - 特定の属性による効率的な検索

   - **適したシナリオ**
     - 複数の属性でのソートが必要
     - 特定のクエリパターンの高速化
     - データの整合性が重要

2. **オートスケーリング**

   - **主な用途**

     - 予測可能な負荷変動への対応
     - 定期的なトラフィックパターン
     - 段階的な容量調整

   - **適したシナリオ**
     - 日中と夜間で負荷が異なる
     - 週次/月次の負荷パターンが存在
     - スケーリングの遅延が許容される

3. **プロビジョンドキャパシティ（アラーム付き）**

   - **主な用途**

     - 安定した負荷パターン
     - 予測可能なトラフィック
     - コスト最適化重視

   - **適したシナリオ**
     - 一定の負荷が継続する
     - 急激な変動が少ない
     - 長期的な容量計画が可能

```mermaid
graph TD
    subgraph "各モードの特性比較"
        T1[応答速度] -->|"即時対応"| M1[オンデマンド]
        T2[コスト] -->|"使用量ベース"| M1

        T1 -->|"数分の遅延"| M2[オートスケーリング]
        T2 -->|"最適化可能"| M2

        T1 -->|"手動調整"| M3[プロビジョンド]
        T2 -->|"予測型"| M3
    end
```

### 不適切な選択肢の問題点

1. **LSI を選択した場合の問題**

   - キャパシティ管理とは無関係
   - トラフィック制御機能なし
   - パフォーマンスチューニングが主目的

2. **オートスケーリングを選択した場合の問題**

   - スケーリングに数分の遅延
   - 急激な負荷変動に対応できない
   - 予測不能なトラフィックには不向き

3. **プロビジョンド（アラーム付き）を選択した場合の問題**

   - 手動介入が必要
   - リアルタイム対応が困難
   - リソースの過剰/過少プロビジョニングのリスク

## AMI と KMS キーの安全な共有戦略

```mermaid
graph TD
    subgraph "共有の基本フロー"
        A1[教育機関のAWSアカウント] -->|"1. AMI共有"| A2[パートナーのAWSアカウント]
        A1 -->|"2. KMSキー権限付与"| A2
    end

    subgraph "必要な設定"
        P1[AMIの設定] -->|"launchPermission"| P2[特定アカウントのみ許可]
        P3[KMSキーポリシー] -->|"kms:Decrypt"| P4[特定アカウントのみ許可]
    end
```

### 正解: B の選択理由

1. **AMI の共有設定**

   - launchPermission で特定アカウントのみに制限
   - 公開設定を避けてセキュリティを確保
   - 最小権限の原則に従う

2. **KMS キーの権限設定**

   - パートナーアカウントに必要最小限の権限を付与
   - 暗号化されたスナップショットの復号を許可
   - キーの管理権限は維持

3. **セキュリティの確保**
   - アクセス制御が明確
   - 権限の範囲が限定的
   - 監査可能性の確保

### 他の選択肢が不適切な理由

```mermaid
graph TD
    subgraph "セキュリティリスク"
        R1[公開設定] -->|"A案の問題"| R1_1["誰でもアクセス可能"]
        R2[別キー信頼] -->|"C案の問題"| R2_1["キー管理の複雑化"]
        R3[S3経由] -->|"D案の問題"| R3_1["追加の攻撃面"]
    end
```

1. **選択肢 A の問題点**

   - AMI を公開設定にすることでセキュリティリスク増大
   - 意図しないアクセスの可能性
   - コンプライアンス要件違反の可能性

2. **選択肢 C の問題点**

   - 複数の KMS キーによる管理の複雑化
   - キー間の信頼関係による追加リスク
   - 運用管理の負担増加

3. **選択肢 D の問題点**
   - S3 を経由する追加のセキュリティリスク
   - 不必要なデータ移動
   - プロセスの複雑化

### 具体的な設定手順

```mermaid
graph TD
    subgraph "AMI共有の実装ステップ"
        S1[Step 1] -->|"AMI共有設定"| S1_1["特定アカウントIDを指定"]
        S2[Step 2] -->|"KMSキーポリシー更新"| S2_1["Decrypt権限付与"]
        S3[Step 3] -->|"検証"| S3_1["アクセステスト"]
    end
```

1. **AMI の共有設定**

   - AWS CLI または Console で launchPermission を設定
   - パートナーの AWS アカウント ID を指定
   - 共有範囲を明確に制限

2. **KMS キーポリシーの設定**

   - パートナーアカウントに kms:Decrypt 権限を付与
   - 必要最小限の権限のみを許可
   - 時間制限の設定を検討

3. **セキュリティベストプラクティス**
   - 定期的な権限の見直し
   - アクセスログの監視
   - 不要になった共有設定の削除

## 並列処理とメッセージキューの設計パターン

```mermaid
graph TD
    subgraph "アーキテクチャ要件"
        R1[並列ジョブ実行] -->|必須| R4[スケーラブル]
        R2[ステートレス設計] -->|必須| R5[データ分離]
        R3[耐久性] -->|必須| R6[メッセージ永続化]
    end

    subgraph "推奨アーキテクチャ"
        SQS[Amazon SQS] -->|"メッセージ保存"| Q[キュー]
        Q -->|"ポーリング"| ASG[Auto Scaling Group]
        ASG -->|"スケーリング"| EC2[EC2インスタンス]
        M[CloudWatchメトリクス] -->|"キュー長による制御"| ASG
    end
```

### 正解: C の選択理由

1. **SQS の利点**

   - メッセージの永続化
   - 耐久性の確保
   - 最低 1 回の処理保証
   - 非同期処理の実現

2. **Auto Scaling の設定**

   - キュー内のメッセージ数に基づくスケーリング
   - 需要に応じた適切なリソース割り当て
   - 効率的なコスト管理

3. **アーキテクチャの特徴**
   - ステートレス設計の実現
   - 高い可用性
   - スケーラビリティの確保

### 各選択肢の詳細分析

```mermaid
graph TD
    subgraph "メッセージングサービスの比較"
        SQS[Amazon SQS] -->|"✓ 推奨"| SQS_F["- メッセージ永続化<br>- 順序保証可能<br>- 再処理機能"]
        SNS[Amazon SNS] -->|"× 不適"| SNS_F["- プッシュ型配信<br>- メッセージ揮発性<br>- 順序保証なし"]
    end

    subgraph "スケーリングメトリクス"
        M1[キュー長] -->|"✓ 最適"| S1["処理負荷と直接的な関連"]
        M2[CPU/ネットワーク] -->|"△ 部分的"| S2["間接的な指標"]
    end
```

1. **選択肢 A の問題点**

   - SNS はプッシュ型で永続化なし
   - CPU 使用率は間接的な指標
   - メッセージの取りこぼしリスク

2. **選択肢 B の問題点**

   - ネットワーク使用量は不適切なメトリクス
   - 処理負荷との相関が低い
   - 非効率なスケーリング

3. **選択肢 D の問題点**
   - SNS のメッセージは一時的
   - 順序保証がない
   - 耐久性要件を満たさない

### 実装のベストプラクティス

```mermaid
graph TD
    subgraph "実装ステップ"
        S1[SQSキュー作成] -->|"設定"| S2[デッドレターキュー]
        S2 -->|"設定"| S3[可視性タイムアウト]
        S3 -->|"設定"| S4[リトライポリシー]
    end

    subgraph "Auto Scaling設定"
        A1[起動テンプレート] -->|"設定"| A2[スケーリングポリシー]
        A2 -->|"設定"| A3[ターゲット追跡]
    end
```

1. **キュー設定**

   - 適切な可視性タイムアウト
   - デッドレターキューの設定
   - メッセージ保持期間の設定

2. **スケーリング設定**

   - キュー長に基づくターゲット追跡
   - 適切なクールダウン期間
   - 最小/最大インスタンス数

3. **監視と運用**
   - CloudWatch メトリクスの監視
   - アラートの設定
   - 処理性能の最適化

## メッセージングサービスと水平スケーリング

```mermaid
graph TD
    subgraph "SQSベースのスケーリング"
        SQS[Amazon SQS] -->|"メッセージ蓄積"| Q[キュー]
        Q -->|"ポーリング"| W1[Worker 1]
        Q -->|"ポーリング"| W2[Worker 2]
        Q -->|"ポーリング"| W3[Worker N]
        M[キュー長] -->|"制御"| AS[Auto Scaling]
        AS -->|"スケール"| WG[Workerグループ]
    end

    subgraph "SNSベースのスケーリング"
        SNS[Amazon SNS] -->|"即時配信"| S1[Subscriber 1]
        SNS -->|"即時配信"| S2[Subscriber 2]
        SNS -->|"即時配信"| S3[Subscriber N]
        style SNS fill:#FFB6C1
    end
```

### SQS が水平スケーリングに適している理由

1. **負荷の制御**

   - メッセージをキューに蓄積可能
   - 処理能力に応じた消費
   - バックプレッシャーの自然な形成

2. **スケーリングの精度**

   - キュー長による直接的な負荷測定
   - 処理待ちタスク数の正確な把握
   - 適切なスケーリング判断が可能

3. **耐障害性**
   - メッセージの永続化
   - 処理の確実性
   - 再試行メカニズム

### SNS の水平スケーリングにおける課題

```mermaid
graph TD
    subgraph "SNSの制限事項"
        P1[即時配信] -->|"問題"| P1_1["負荷制御困難"]
        P2[プッシュモデル] -->|"問題"| P2_1["バックプレッシャーなし"]
        P3[一時的な配信] -->|"問題"| P3_1["メッセージロスト"]
    end
```

1. **負荷制御の難しさ**

   - 即時配信によるスパイク
   - 処理能力を超えた配信
   - バッファリング機能の欠如

2. **スケーリング指標の不適切さ**

   - メッセージ数の把握が困難
   - 処理待ちの測定不可
   - 適切なスケーリング判断が困難

3. **メッセージの信頼性**
   - 配信保証の限界
   - 再試行機能の制限
   - 処理の確実性が低い

### SNS の適切な使用シナリオ

```mermaid
graph TD
    subgraph "SNSの有効な使用例"
        U1[通知配信] -->|"適切"| U1_1["プッシュ通知"]
        U2[イベント配信] -->|"適切"| U2_1["ファンアウト"]
        U3[トリガー] -->|"適切"| U3_1["Lambda起動"]
    end
```

1. **通知システム**

   - モバイルプッシュ通知
   - メール配信
   - アラート通知

2. **イベントブロードキャスト**

   - 複数サービスへの同時通知
   - ファンアウトパターン
   - イベント駆動アーキテクチャ

3. **トリガーメカニズム**
   - Lambda 関数の起動
   - マイクロサービス間通信
   - 非同期ワークフロー開始

### SQS と SNS の組み合わせパターン

```mermaid
graph TD
    subgraph "ハイブリッドパターン"
        SNS[SNS] -->|"ファンアウト"| SQS1[SQS Queue 1]
        SNS -->|"ファンアウト"| SQS2[SQS Queue 2]
        SQS1 -->|"制御された処理"| W1[Worker Group 1]
        SQS2 -->|"制御された処理"| W2[Worker Group 2]
    end
```

1. **ファンアウト＋キュー**

   - SNS でのメッセージ配信
   - SQS での負荷制御
   - 適切なスケーリング

2. **ベストプラクティス**

   - SNS は配信のみに使用
   - SQS で処理を制御
   - 各コンポーネントの長所を活用

3. **利点**
   - 柔軟な配信
   - 確実な処理
   - スケーラブルな設計

## グローバル配信のためのアーキテクチャ選択

```mermaid
graph TD
    subgraph "CloudFrontアーキテクチャ"
        CF[CloudFront] -->|"キャッシュ"| EL1[エッジロケーション1]
        CF -->|"キャッシュ"| EL2[エッジロケーション2]
        EL1 -->|"キャッシュヒット"| U1[アジアユーザー]
        EL2 -->|"キャッシュヒット"| U2[米国ユーザー]
        EL1 -.->|"キャッシュミス"| O[オリジンサーバー]
        EL2 -.->|"キャッシュミス"| O
        style CF fill:#90EE90
    end
```

### CloudFront が最適な理由

1. **パフォーマンスの最適化**

   - エッジロケーションでのキャッシュ
   - 最寄りのエッジからの配信
   - 動的/静的コンテンツの最適化

2. **実装の容易さ**

   - オリジンサーバーの変更不要
   - 迅速な展開が可能
   - 段階的な移行

3. **コスト効率**
   - トラフィック削減
   - オリジンサーバーの負荷軽減
   - 帯域幅コストの最適化

### 他の選択肢の課題

```mermaid
graph TD
    subgraph "アプローチ比較"
        A[EC2移行] -->|"問題"| A1["地理的距離による<br>レイテンシー"]
        B[S3+レプリケーション] -->|"問題"| B1["動的コンテンツ<br>非対応"]
        D[Route 53] -->|"問題"| D1["キャッシュ機能<br>なし"]
    end
```

1. **EC2 移行の問題点**

   - 地理的な距離による遅延
   - リージョン固定の制限
   - スケーリングの複雑さ

2. **S3 レプリケーションの問題点**

   - 動的コンテンツに非対応
   - 更新の遅延
   - 複雑な同期管理

3. **Route 53 の限界**
   - キャッシュ機能なし
   - 単純な DNS ルーティング
   - エンドユーザー体験の制限

### CloudFront の具体的なメリット

```mermaid
graph TD
    subgraph "CloudFrontの利点"
        P1[キャッシュ] -->|"効果"| P1_1["レイテンシー削減"]
        P2[圧縮] -->|"効果"| P2_1["転送量削減"]
        P3[SSL/TLS] -->|"効果"| P3_1["セキュリティ強化"]
    end
```

1. **キャッシュ戦略**

   - カスタマイズ可能なキャッシュ設定
   - TTL の柔軟な制御
   - 動的コンテンツの最適化

2. **セキュリティ**

   - SSL/TLS 対応
   - WAF 統合
   - DDoS 保護

3. **運用管理**
   - 詳細なモニタリング
   - リアルタイムログ
   - 簡単な設定変更

### 実装のベストプラクティス

```mermaid
graph TD
    subgraph "実装ステップ"
        S1[CloudFront設定] -->|"Step 1"| S1_1["オリジン設定"]
        S1_1 -->|"Step 2"| S2["キャッシュ設定"]
        S2 -->|"Step 3"| S3["SSL/TLS設定"]
    end
```

1. **初期設定**

   - オリジンサーバーの指定
   - キャッシュ動作の設定
   - SSL 証明書の設定

2. **最適化設定**

   - キャッシュ TTL の調整
   - 圧縮の有効化
   - カスタムヘッダーの設定

3. **監視と調整**
   - アクセスログの分析
   - キャッシュヒット率の監視
   - パフォーマンスの最適化

## EC2 インスタンスの購入オプション選択戦略

```mermaid
graph TD
    subgraph "要件分析"
        R1[本番環境] -->|"24時間稼働"| R4[安定性重視]
        R2[開発/テスト環境] -->|"8時間稼働"| R5[コスト重視]
        R3[CPU使用率] -->|"ピーク40%"| R6[リソース予測可]
    end

    subgraph "最適な組み合わせ"
        P1[本番環境] -->|"リザーブド"| P3[長期安定稼働]
        P2[開発/テスト環境] -->|"オンデマンド"| P4[柔軟な利用]
    end
```

### 各購入オプションの特徴と適用シナリオ

1. **リザーブドインスタンス**

   - **メリット**

     - 大幅な割引（最大 72%）
     - 安定した可用性
     - 予算計画が立てやすい

   - **最適な用途**
     - 24 時間稼働システム
     - 長期利用（1-3 年）
     - 安定した負荷

2. **オンデマンドインスタンス**

   - **メリット**

     - 柔軟な起動/停止
     - 最小利用時間なし
     - 初期費用なし

   - **最適な用途**
     - 開発/テスト環境
     - 変動の大きい負荷
     - 短期プロジェクト

3. **スポットインスタンス**

   - **メリット**

     - 最大 90%割引
     - コスト最適化
     - 一時的な処理に最適

   - **デメリット**
     - 突然の中断リスク
     - 可用性保証なし
     - 本番環境には不向き

### 環境別の最適な選択

```mermaid
graph TD
    subgraph "本番環境の選択"
        PR1[リザーブド] -->|"✓ 推奨"| PR2["- 安定稼働<br>- コスト予測可能<br>- 長期利用"]
        SP1[スポット] -->|"× 不適"| SP2["- 中断リスク<br>- 可用性低下<br>- SLA未達"]
    end

    subgraph "開発/テスト環境の選択"
        OD1[オンデマンド] -->|"✓ 推奨"| OD2["- 柔軟な利用<br>- 自動停止可能<br>- コスト制御"]
        RV1[リザーブド] -->|"× 不適"| RV2["- 過剰な支払い<br>- 柔軟性低下<br>- リソース固定"]
    end
```

### コスト最適化のポイント

1. **本番環境**

   - リザーブドインスタンスの適切な期間選択
   - インスタンスサイズの最適化
   - 支払いオプションの検討（全額前払い/部分前払い/前払いなし）

2. **開発/テスト環境**

   - 自動停止スケジュールの実装
   - 必要最小限のインスタンスサイズ
   - 不要なリソースの迅速な削除

3. **全体的な戦略**
   - 定期的な使用状況の監視
   - コスト配分の可視化
   - リソース使用効率の最適化

### 実装のベストプラクティス

```mermaid
graph TD
    subgraph "自動化の実装"
        A1[CloudWatch] -->|"スケジュール"| A2[Lambda]
        A2 -->|"停止"| A3[開発/テスト環境EC2]
        A1 -->|"モニタリング"| A4[アラート]
    end
```

1. **スケジュール管理**

   - AWS Lambda による自動停止
   - CloudWatch Events でスケジュール設定
   - タグベースの管理

2. **コスト監視**

   - CloudWatch メトリクスの活用
   - コストアラートの設定
   - 予算管理の徹底

3. **最適化プロセス**
   - 定期的な使用パターン分析
   - インスタンスサイズの見直し
   - 購入オプションの再評価

## S3 データ保護要件の分析と実装

```mermaid
graph TD
    subgraph "要件の分解"
        R1[規制要件] -->|"必須"| R4["保存後の<br>編集禁止"]
        R2[規制要件] -->|"必須"| R5["保存後の<br>削除禁止"]
        R3[業務要件] -->|"必要"| R6["アップロード<br>機能"]
    end

    subgraph "必要な保護レベル"
        P1[WORM対応] -->|"Write Once,<br>Read Many"| P4[変更不可]
        P2[完全性保護] -->|"データ保護"| P5[改ざん防止]
        P3[アクセス制御] -->|"権限管理"| P6[参照制御]
    end
```

### 要件の読み解き方

1. **キーワードの特定**

   - "保存後"→ データ登録後の処理
   - "編集や削除ができなくなる"→ WORM（Write Once, Read Many）要件
   - "規制の要件"→ コンプライアンス要件

2. **必要な機能の整理**

   - データの不変性確保
   - 完全性の保証
   - アクセス制御

3. **制約条件の確認**
   - 学生によるアップロード
   - ウェブ/モバイル対応
   - 長期保存の必要性

### 選択肢の評価基準

```mermaid
graph TD
    subgraph "保護機能の比較"
        V[バージョニング] -->|"履歴保持"| V1["変更追跡"]
        L[オブジェクトロック] -->|"WORM"| L1["変更防止"]
        P[バケットポリシー] -->|"アクセス制御"| P1["権限管理"]
    end
```

1. **S3 オブジェクトロック**

   - **強み**

     - WORM 機能の提供
     - 法的要件への対応
     - 管理者でも変更不可

   - **用途**
     - コンプライアンス対応
     - 監査データの保護
     - 法的記録の保持

2. **S3 バージョニング**

   - **強み**

     - 変更履歴の保持
     - 誤削除からの復旧
     - データの追跡可能性

   - **用途**
     - 変更管理
     - バックアップ
     - 監査証跡

### 正解の実装方法

```mermaid
graph TD
    subgraph "実装ステップ"
        S1[S3バケット作成] -->|"Step 1"| S2[バージョニング有効化]
        S2 -->|"Step 2"| S3[オブジェクトロック設定]
        S3 -->|"Step 3"| S4[保持期間設定]
    end
```

1. **基本設定**

   - バケットの作成
   - バージョニングの有効化
   - オブジェクトロックの設定

2. **保護設定**

   - 保持期間の指定
   - コンプライアンスモードの選択
   - リーガルホールドの検討

3. **アクセス管理**
   - IAM ポリシーの設定
   - バケットポリシーの構成
   - 最小権限の原則適用

### 他の選択肢が不適切な理由

1. **バケットポリシーのみ（選択肢 B）**

   - 管理者による変更が可能
   - ポリシー自体の変更リスク
   - WORM 要件を満たさない

2. **ACL のみ（選択肢 C）**

   - アクセス制御のみ
   - 削除保護が不十分
   - 管理者権限での変更可能

3. **チェックサム（選択肢 D）**
   - 改ざん検知のみ
   - 変更/削除の防止なし
   - コンプライアンス非対応
